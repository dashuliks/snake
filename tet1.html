<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pink Tetris</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: #ffc4e1 url('data:image/svg+xml,<svg xmlns="kitty.jpg" width="200" height="200"><defs><pattern id="kitty" x="0" y="0" width="200" height="200" patternUnits="userSpaceOnUse"><g opacity="0.3"><ellipse cx="60" cy="70" rx="35" ry="40" fill="%23ffb3d9" stroke="%23cc8fb3" stroke-width="2"/><ellipse cx="50" cy="65" rx="3" ry="4" fill="%23cc8fb3"/><ellipse cx="70" cy="65" rx="3" ry="4" fill="%23cc8fb3"/><ellipse cx="60" cy="72" rx="2" ry="3" fill="%23ffcceb"/><path d="M 45 55 Q 45 50 40 48 M 45 60 Q 40 60 35 58 M 45 65 Q 40 67 35 67" stroke="%23cc8fb3" stroke-width="1.5" fill="none"/><path d="M 75 55 Q 75 50 80 48 M 75 60 Q 80 60 85 58 M 75 65 Q 80 67 85 67" stroke="%23cc8fb3" stroke-width="1.5" fill="none"/><ellipse cx="60" cy="45" rx="15" ry="12" fill="%23ff99cc" stroke="%23cc8fb3" stroke-width="2"/><ellipse cx="60" cy="44" rx="8" ry="6" fill="%23ffb3d9"/><rect x="50" y="85" width="20" height="15" rx="3" fill="%23ff99cc" stroke="%23cc8fb3" stroke-width="2"/></g><g opacity="0.3" transform="translate(120, 120)"><ellipse cx="60" cy="70" rx="35" ry="40" fill="%23ffb3d9" stroke="%23cc8fb3" stroke-width="2"/><ellipse cx="50" cy="65" rx="3" ry="4" fill="%23cc8fb3"/><ellipse cx="70" cy="65" rx="3" ry="4" fill="%23cc8fb3"/><ellipse cx="60" cy="72" rx="2" ry="3" fill="%23ffcceb"/><path d="M 45 55 Q 45 50 40 48 M 45 60 Q 40 60 35 58 M 45 65 Q 40 67 35 67" stroke="%23cc8fb3" stroke-width="1.5" fill="none"/><path d="M 75 55 Q 75 50 80 48 M 75 60 Q 80 60 85 58 M 75 65 Q 80 67 85 67" stroke="%23cc8fb3" stroke-width="1.5" fill="none"/><ellipse cx="60" cy="45" rx="15" ry="12" fill="%23ff99cc" stroke="%23cc8fb3" stroke-width="2"/><ellipse cx="60" cy="44" rx="8" ry="6" fill="%23ffb3d9"/><rect x="50" y="85" width="20" height="15" rx="3" fill="%23ff99cc" stroke="%23cc8fb3" stroke-width="2"/></g></pattern></defs><rect width="200" height="200" fill="url(%23kitty)"/></svg>') repeat;
      transition: background 0.3s ease;
      padding: 20px;
    }

    body.dark-theme {
      background: linear-gradient(135deg, #c2185b 0%, #880e4f 100%);
    }

    .container {
      text-align: center;
      max-width: 800px;
      width: 100%;
    }

    h1 {
      color: #d946a6;
      margin-bottom: 20px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(217, 70, 166, 0.2);
    }

    body.dark-theme h1 {
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .game-area {
      display: flex;
      gap: 20px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }

    .game-wrapper {
      position: relative;
    }

    #gameCanvas {
      background: white;
      border-radius: 15px;
      box-shadow: 0 8px 30px rgba(217, 70, 166, 0.3);
      display: block;
    }

    body.dark-theme #gameCanvas {
      background: rgba(255, 255, 255, 0.95);
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .info-box {
      background: white;
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(217, 70, 166, 0.2);
      min-width: 150px;
    }

    body.dark-theme .info-box {
      background: rgba(255, 255, 255, 0.95);
    }

    .info-label {
      font-size: 0.9em;
      color: #d946a6;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .info-value {
      font-size: 2em;
      font-weight: bold;
      color: #ff69b4;
    }

    #nextCanvas {
      background: #ffe6f2;
      border-radius: 10px;
      display: block;
      margin: 10px auto 0;
    }

    .settings {
      background: white;
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(217, 70, 166, 0.2);
      margin-bottom: 20px;
    }

    body.dark-theme .settings {
      background: rgba(255, 255, 255, 0.95);
    }

    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      gap: 10px;
    }

    .setting-row:last-child {
      margin-bottom: 0;
    }

    .setting-label {
      font-weight: 600;
      color: #d946a6;
    }

    .setting-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      background: linear-gradient(135deg, #ff69b4 0%, #d946a6 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 25px;
      font-size: 0.95em;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(217, 70, 166, 0.3);
      transition: all 0.3s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(217, 70, 166, 0.4);
    }

    button:active {
      transform: translateY(0);
    }

    .setting-buttons button.active {
      background: linear-gradient(135deg, #d946a6 0%, #a21d72 100%);
    }

    .toggle {
      width: 50px;
      height: 26px;
      background: #ddd;
      border-radius: 13px;
      position: relative;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .toggle.active {
      background: linear-gradient(135deg, #ff69b4 0%, #d946a6 100%);
    }

    .toggle-slider {
      width: 22px;
      height: 22px;
      background: white;
      border-radius: 50%;
      position: absolute;
      top: 2px;
      left: 2px;
      transition: left 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle.active .toggle-slider {
      left: 26px;
    }

    .mobile-controls {
      display: none;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 20px;
    }

    @media (max-width: 768px) {
      .mobile-controls {
        display: flex;
      }
    }

    .control-button {
      width: 60px;
      height: 60px;
      font-size: 1.5em;
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .control-row {
      display: flex;
      gap: 10px;
      width: 100%;
      justify-content: center;
    }

    .game-over-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 10;
    }

    .game-over-overlay.show {
      display: flex;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .game-over-overlay h2 {
      color: #d946a6;
      font-size: 2.5em;
      margin-bottom: 20px;
    }

    .game-over-overlay p {
      color: #ff69b4;
      font-size: 1.3em;
      margin-bottom: 30px;
    }

    .instructions {
      color: #d946a6;
      font-size: 0.9em;
      margin-top: 15px;
      line-height: 1.6;
    }

    body.dark-theme .instructions {
      color: white;
    }

    @media (max-width: 600px) {
      h1 {
        font-size: 2em;
      }

      .game-area {
        flex-direction: column;
        align-items: center;
      }

      #gameCanvas {
        width: 100%;
        max-width: 300px;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üéÆ Pink Tetris</h1>

    <div class="settings">
      <div class="setting-row">
        <span class="setting-label">Sound</span>
        <div class="toggle active" id="soundToggle">
          <div class="toggle-slider"></div>
        </div>
      </div>
      <div class="setting-row">
        <span class="setting-label">Speed</span>
        <div class="setting-buttons">
          <button class="speed-btn" data-speed="1000">Slow</button>
          <button class="speed-btn active" data-speed="700">Normal</button>
          <button class="speed-btn" data-speed="400">Fast</button>
        </div>
      </div>
      <div class="setting-row">
        <span class="setting-label">Theme</span>
        <div class="setting-buttons">
          <button class="theme-btn active" data-theme="light">Light</button>
          <button class="theme-btn" data-theme="dark">Dark</button>
        </div>
      </div>
      <div class="setting-row">
        <button id="restartBtn" style="width: 100%;">Restart Game</button>
      </div>
    </div>

    <div class="game-area">
      <div class="game-wrapper">
        <canvas id="gameCanvas" width="300" height="600"></canvas>
        <div class="game-over-overlay" id="gameOver">
          <h2>Game Over!</h2>
          <p>Score: <span id="finalScore">0</span></p>
          <button id="playAgainBtn">Play Again</button>
        </div>
      </div>

      <div class="side-panel">
        <div class="info-box">
          <div class="info-label">Score</div>
          <div class="info-value" id="score">0</div>
        </div>
        <div class="info-box">
          <div class="info-label">Lines</div>
          <div class="info-value" id="lines">0</div>
        </div>
        <div class="info-box">
          <div class="info-label">Level</div>
          <div class="info-value" id="level">1</div>
        </div>
        <div class="info-box">
          <div class="info-label">Next</div>
          <canvas id="nextCanvas" width="100" height="100"></canvas>
        </div>
      </div>
    </div>

    <div class="mobile-controls">
      <div class="control-row">
        <button class="control-button" id="rotateBtn">üîÑ</button>
      </div>
      <div class="control-row">
        <button class="control-button" id="leftBtn">‚Üê</button>
        <button class="control-button" id="downBtn">‚Üì</button>
        <button class="control-button" id="rightBtn">‚Üí</button>
      </div>
      <div class="control-row">
        <button class="control-button" id="dropBtn">‚¨áÔ∏è</button>
      </div>
    </div>

    <p class="instructions">
      Desktop: Arrow Keys (move), Up/W (rotate), Space (hard drop)<br>
      Mobile: Use the buttons below
    </p>
  </div>

  <script>
    // Tetromino shapes and colors
    const SHAPES = {
      I: { shape: [[1,1,1,1]], color: '#ff69b4' },
      O: { shape: [[1,1],[1,1]], color: '#ff85c0' },
      T: { shape: [[0,1,0],[1,1,1]], color: '#d946a6' },
      S: { shape: [[0,1,1],[1,1,0]], color: '#ffa6d5' },
      Z: { shape: [[1,1,0],[0,1,1]], color: '#ff1493' },
      J: { shape: [[1,0,0],[1,1,1]], color: '#c71585' },
      L: { shape: [[0,0,1],[1,1,1]], color: '#ff6eb4' }
    };

    class TetrisGame {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.nextCanvas = document.getElementById('nextCanvas');
        this.nextCtx = this.nextCanvas.getContext('2d');
        
        this.cols = 10;
        this.rows = 20;
        this.blockSize = this.canvas.width / this.cols;
        
        // Game state
        this.board = Array(this.rows).fill(null).map(() => Array(this.cols).fill(0));
        this.currentPiece = null;
        this.nextPiece = null;
        this.currentX = 0;
        this.currentY = 0;
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.gameOver = false;
        this.isPaused = false;
        this.baseSpeed = 700;
        this.dropInterval = null;
        this.soundEnabled = true;
        this.audioContext = null;
        
        this.init();
      }

      init() {
        this.spawnPiece();
        this.spawnNextPiece();
        this.draw();
        this.drawNext();
        this.startDrop();
        this.setupControls();
        this.updateDisplay();
      }

      setupControls() {
        document.addEventListener('keydown', (e) => {
          if (this.gameOver) return;
          
          switch(e.key) {
            case 'ArrowLeft':
            case 'a':
            case 'A':
              e.preventDefault();
              this.moveLeft();
              break;
            case 'ArrowRight':
            case 'd':
            case 'D':
              e.preventDefault();
              this.moveRight();
              break;
            case 'ArrowDown':
            case 's':
            case 'S':
              e.preventDefault();
              this.moveDown();
              break;
            case 'ArrowUp':
            case 'w':
            case 'W':
              e.preventDefault();
              this.rotate();
              break;
            case ' ':
              e.preventDefault();
              this.hardDrop();
              break;
          }
        });

        // Mobile controls
        document.getElementById('leftBtn').addEventListener('click', () => this.moveLeft());
        document.getElementById('rightBtn').addEventListener('click', () => this.moveRight());
        document.getElementById('downBtn').addEventListener('click', () => this.moveDown());
        document.getElementById('rotateBtn').addEventListener('click', () => this.rotate());
        document.getElementById('dropBtn').addEventListener('click', () => this.hardDrop());
      }

      spawnPiece() {
        if (this.nextPiece) {
          this.currentPiece = this.nextPiece;
        } else {
          const shapes = Object.keys(SHAPES);
          const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
          this.currentPiece = {
            shape: SHAPES[randomShape].shape,
            color: SHAPES[randomShape].color
          };
        }
        
        this.currentX = Math.floor(this.cols / 2) - Math.floor(this.currentPiece.shape[0].length / 2);
        this.currentY = 0;
        
        if (this.collision()) {
          this.endGame();
        }
        
        this.spawnNextPiece();
      }

      spawnNextPiece() {
        const shapes = Object.keys(SHAPES);
        const randomShape = shapes[Math.floor(Math.random() * shapes.length)];
        this.nextPiece = {
          shape: SHAPES[randomShape].shape,
          color: SHAPES[randomShape].color
        };
        this.drawNext();
      }

      collision(offsetX = 0, offsetY = 0, shape = this.currentPiece.shape) {
        for (let y = 0; y < shape.length; y++) {
          for (let x = 0; x < shape[y].length; x++) {
            if (shape[y][x]) {
              const newX = this.currentX + x + offsetX;
              const newY = this.currentY + y + offsetY;
              
              if (newX < 0 || newX >= this.cols || newY >= this.rows) {
                return true;
              }
              
              if (newY >= 0 && this.board[newY][newX]) {
                return true;
              }
            }
          }
        }
        return false;
      }

      moveLeft() {
        if (!this.collision(-1, 0)) {
          this.currentX--;
          this.draw();
          this.playMoveSound();
        }
      }

      moveRight() {
        if (!this.collision(1, 0)) {
          this.currentX++;
          this.draw();
          this.playMoveSound();
        }
      }

      moveDown() {
        if (!this.collision(0, 1)) {
          this.currentY++;
          this.draw();
          return true;
        } else {
          this.mergePiece();
          return false;
        }
      }

      hardDrop() {
        while (this.moveDown()) {}
        this.playDropSound();
      }

      rotate() {
        const rotated = this.currentPiece.shape[0].map((_, i) =>
          this.currentPiece.shape.map(row => row[i]).reverse()
        );
        
        if (!this.collision(0, 0, rotated)) {
          this.currentPiece.shape = rotated;
          this.draw();
          this.playRotateSound();
        }
      }

      mergePiece() {
        for (let y = 0; y < this.currentPiece.shape.length; y++) {
          for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
            if (this.currentPiece.shape[y][x]) {
              const boardY = this.currentY + y;
              const boardX = this.currentX + x;
              if (boardY >= 0) {
                this.board[boardY][boardX] = this.currentPiece.color;
              }
            }
          }
        }
        
        this.clearLines();
        this.spawnPiece();
        this.draw();
      }

      clearLines() {
        let linesCleared = 0;
        
        for (let y = this.rows - 1; y >= 0; y--) {
          if (this.board[y].every(cell => cell !== 0)) {
            this.board.splice(y, 1);
            this.board.unshift(Array(this.cols).fill(0));
            linesCleared++;
            y++;
          }
        }
        
        if (linesCleared > 0) {
          this.lines += linesCleared;
          this.score += linesCleared * 100 * this.level;
          this.level = Math.floor(this.lines / 10) + 1;
          this.updateDisplay();
          this.playLineClearSound();
          
          // Increase speed
          this.baseSpeed = Math.max(100, 700 - (this.level - 1) * 50);
          this.startDrop();
        }
      }

      startDrop() {
        if (this.dropInterval) {
          clearInterval(this.dropInterval);
        }
        this.dropInterval = setInterval(() => {
          if (!this.gameOver) {
            this.moveDown();
          }
        }, this.baseSpeed);
      }

      draw() {
        // Clear canvas
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid
        this.ctx.strokeStyle = '#ffe6f2';
        this.ctx.lineWidth = 1;
        for (let x = 0; x <= this.cols; x++) {
          this.ctx.beginPath();
          this.ctx.moveTo(x * this.blockSize, 0);
          this.ctx.lineTo(x * this.blockSize, this.canvas.height);
          this.ctx.stroke();
        }
        for (let y = 0; y <= this.rows; y++) {
          this.ctx.beginPath();
          this.ctx.moveTo(0, y * this.blockSize);
          this.ctx.lineTo(this.canvas.width, y * this.blockSize);
          this.ctx.stroke();
        }
        
        // Draw board pieces
        for (let y = 0; y < this.rows; y++) {
          for (let x = 0; x < this.cols; x++) {
            if (this.board[y][x]) {
              this.drawBlock(x, y, this.board[y][x]);
            }
          }
        }
        
        // Draw current piece
        if (this.currentPiece) {
          for (let y = 0; y < this.currentPiece.shape.length; y++) {
            for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
              if (this.currentPiece.shape[y][x]) {
                this.drawBlock(this.currentX + x, this.currentY + y, this.currentPiece.color);
              }
            }
          }
        }
      }

      drawBlock(x, y, color) {
        const padding = 2;
        const size = this.blockSize - padding * 2;
        const posX = x * this.blockSize + padding;
        const posY = y * this.blockSize + padding;
        
        // Draw rounded rectangle with gradient
        const gradient = this.ctx.createLinearGradient(posX, posY, posX + size, posY + size);
        gradient.addColorStop(0, color);
        gradient.addColorStop(1, this.darkenColor(color, 20));
        
        this.ctx.fillStyle = gradient;
        this.ctx.shadowColor = color;
        this.ctx.shadowBlur = 10;
        this.roundRect(posX, posY, size, size, 5);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
        
        // Inner highlight
        this.ctx.strokeStyle = this.lightenColor(color, 30);
        this.ctx.lineWidth = 2;
        this.roundRect(posX + 2, posY + 2, size - 4, size - 4, 3);
        this.ctx.stroke();
      }

      roundRect(x, y, width, height, radius) {
        this.ctx.beginPath();
        this.ctx.moveTo(x + radius, y);
        this.ctx.lineTo(x + width - radius, y);
        this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        this.ctx.lineTo(x + width, y + height - radius);
        this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        this.ctx.lineTo(x + radius, y + height);
        this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        this.ctx.lineTo(x, y + radius);
        this.ctx.quadraticCurveTo(x, y, x + radius, y);
        this.ctx.closePath();
      }

      drawNext() {
        this.nextCtx.fillStyle = '#ffe6f2';
        this.nextCtx.fillRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);
        
        if (!this.nextPiece) return;
        
        const blockSize = 20;
        const offsetX = (this.nextCanvas.width - this.nextPiece.shape[0].length * blockSize) / 2;
        const offsetY = (this.nextCanvas.height - this.nextPiece.shape.length * blockSize) / 2;
        
        for (let y = 0; y < this.nextPiece.shape.length; y++) {
          for (let x = 0; x < this.nextPiece.shape[y].length; x++) {
            if (this.nextPiece.shape[y][x]) {
              const posX = offsetX + x * blockSize + 2;
              const posY = offsetY + y * blockSize + 2;
              
              this.nextCtx.fillStyle = this.nextPiece.color;
              this.nextCtx.shadowColor = this.nextPiece.color;
              this.nextCtx.shadowBlur = 5;
              this.roundRectNext(posX, posY, blockSize - 4, blockSize - 4, 3);
              this.nextCtx.fill();
              this.nextCtx.shadowBlur = 0;
            }
          }
        }
      }

      roundRectNext(x, y, width, height, radius) {
        this.nextCtx.beginPath();
        this.nextCtx.moveTo(x + radius, y);
        this.nextCtx.lineTo(x + width - radius, y);
        this.nextCtx.quadraticCurveTo(x + width, y, x + width, y + radius);
        this.nextCtx.lineTo(x + width, y + height - radius);
        this.nextCtx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        this.nextCtx.lineTo(x + radius, y + height);
        this.nextCtx.quadraticCurveTo(x, y + height, x, y + height - radius);
        this.nextCtx.lineTo(x, y + radius);
        this.nextCtx.quadraticCurveTo(x, y, x + radius, y);
        this.nextCtx.closePath();
      }

      lightenColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
          (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
          (B < 255 ? B < 1 ? 0 : B : 255))
          .toString(16).slice(1);
      }

      darkenColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) - amt;
        const G = (num >> 8 & 0x00FF) - amt;
        const B = (num & 0x0000FF) - amt;
        return '#' + (0x1000000 + (R > 0 ? R : 0) * 0x10000 +
          (G > 0 ? G : 0) * 0x100 + (B > 0 ? B : 0))
          .toString(16).slice(1);
      }

      updateDisplay() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('lines').textContent = this.lines;
        document.getElementById('level').textContent = this.level;
      }

      playSound(frequency, duration, type = 'sine') {
        if (!this.soundEnabled) return;
        try {
          if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          oscillator.frequency.value = frequency;
          oscillator.type = type;
          gainNode.gain.setValueAtTime(0.2, this.audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
          oscillator.start(this.audioContext.currentTime);
          oscillator.stop(this.audioContext.currentTime + duration);
        } catch (e) {
          console.log('Audio not supported');
        }
      }

      playMoveSound() { this.playSound(400, 0.05); }
      playRotateSound() { this.playSound(600, 0.08); }
      playDropSound() { this.playSound(300, 0.15); }
      playLineClearSound() { 
        this.playSound(800, 0.1);
        setTimeout(() => this.playSound(1000, 0.1), 100);
      }
      playGameOverSound() { 
        this.playSound(200, 0.3);
        setTimeout(() => this.playSound(150, 0.5), 300);
      }

      endGame() {
        this.gameOver = true;
        clearInterval(this.dropInterval);
        this.playGameOverSound();
        document.getElementById('finalScore').textContent = this.score;
        document.getElementById('gameOver').classList.add('show');
      }

      restart() {
        this.board = Array(this.rows).fill(null).map(() => Array(this.cols).fill(0));
        this.score = 0;
        this.lines = 0;
        this.level = 1;
        this.gameOver = false;
        this.baseSpeed = 700;
        document.getElementById('gameOver').classList.remove('show');
        this.updateDisplay();
        this.spawnPiece();
        this.spawnNextPiece();
        this.draw();
        this.startDrop();
      }
    }

    // Initialize game
    const game = new TetrisGame();

    // Restart button
    document.getElementById('restartBtn').addEventListener('click', () => {
      game.restart();
    });

    document.getElementById('playAgainBtn').addEventListener('click', () => {
      game.restart();
    });

    // Settings controls
    document.getElementById('soundToggle').addEventListener('click', function() {
      this.classList.toggle('active');
      game.soundEnabled = this.classList.contains('active');
    });

    document.querySelectorAll('.speed-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        game.baseSpeed = parseInt(this.dataset.speed);
        game.startDrop();
      });
    });

    document.querySelectorAll('.theme-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        document.querySelectorAll('.theme-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        if (this.dataset.theme === 'dark') {
          document.body.classList.add('dark-theme');
        } else {
          document.body.classList.remove('dark-theme');
        }
      });
    });
  </script>
</body>
</html>